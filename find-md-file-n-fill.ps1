<#
.SYNOPSIS
    Finds empty Markdown files and populates them with KOREAN content generated by gemini-cli, using a robust cmd.exe wrapper method.

.DESCRIPTION
    This script provides the most stable way to pass data to an external program by leveraging the classic cmd.exe for I/O redirection.
    1. It creates a temporary file for the prompt and a temporary file for the response.
    2. It uses `cmd.exe /c "gemini < prompt.txt > response.txt"` to handle all I/O, bypassing PowerShell's version-specific limitations and VSCode extension conflicts.
    3. PowerShell then safely reads the UTF-8 encoded response file.
    4. This method is the most compatible and robust solution for ensuring perfect Korean character handling.
    5. Both temporary files are deleted after use.

.NOTES
    Author: Your Name
    Project: PS-obsi-gemcli-1
    Workflow: cmd.exe wrapper for maximum compatibility.
    Prerequisites:
    - PowerShell 5.1 or later (works on any version).
    - gemini-cli must be installed and accessible via the system's PATH.
#>

# ----------------------------------------------------------------------------------
# 사용자 설정 영역 (USER CONFIGURATION SECTION)
# 스크립트 실행 전 아래 경로들을 자신의 환경에 맞게 수정하세요.
# ----------------------------------------------------------------------------------

# 수정하세요!
# 콘텐츠를 채울 마크다운 파일들이 있는 최상위 폴더 경로를 지정하세요.
$targetDirectory = "H:\내 드라이브\Obsidian 보관소\obsi-moc-5\40-knowledge-resources-input\41-computer-science\41-30-Software-Engineering\41-31-Programming-Language\6-PowerShell"


# 수정하세요!
# Gemini 답변 스타일 가이드 파일(GEMINI.md)의 전체 경로를 지정하세요.
# 이 파일은 한글 답변을 생성하도록 지시하는 내용이어야 합니다.
$geminiMdPath = "H:\내 드라이브\Obsidian 보관소\obsi-find-n-fill\obsidian-find-n-fill\context-prompt-gemini.md\cs-prog-lang-ko.md"


# ----------------------------------------------------------------------------------
# 스크립트 메인 로직 (DO NOT EDIT BELOW THIS LINE unless you know what you are doing)
# ----------------------------------------------------------------------------------

# --- 1. 설정 검증 (Validate Settings) ---
Write-Host "--- 스크립트 시작: 마크다운 파일 자동 채우기 (cmd.exe 래퍼 방식) ---" -ForegroundColor Cyan

if (-not (Test-Path -Path $targetDirectory -PathType Container)) {
    Write-Error "오류: 타겟 디렉토리를 찾을 수 없습니다. 경로를 확인하세요: '$targetDirectory'"
    return
}

if (-not (Test-Path -Path $geminiMdPath -PathType Leaf)) {
    Write-Error "오류: GEMINI.md 파일을 찾을 수 없습니다. 경로를 확인하세요: '$geminiMdPath'"
    return
}

# --- 2. 스타일 가이드 로드 (Load Style Guide) ---
try {
    $styleGuide = Get-Content -Path $geminiMdPath -Raw -Encoding UTF8 -ErrorAction Stop
    Write-Host "✅ 스타일 가이드 로드 완료: $geminiMdPath" -ForegroundColor Green
}
catch {
    Write-Error "치명적 오류: 스타일 가이드 파일($geminiMdPath)을 읽는 중 문제가 발생했습니다."
    return
}


# --- 3. 마크다운 파일 탐색 및 처리 (Find and Process Markdown Files) ---
Write-Host "📂 '$targetDirectory' 에서 마크다운 파일 탐색을 시작합니다..."

$markdownFiles = Get-ChildItem -Path $targetDirectory -Recurse -Filter *.md

if ($null -eq $markdownFiles) {
    Write-Warning "발견된 마크다운 파일이 없습니다. 작업을 종료합니다."
    return
}

Write-Host "총 $($markdownFiles.Count)개의 마크다운 파일을 발견했습니다. 비어있는 파일을 확인합니다."

foreach ($file in $markdownFiles) {
    if ($file.Length -eq 0) {
        Write-Host "------------------------------------------------------------"
        Write-Host "🎯 처리 대상 발견: $($file.FullName)" -ForegroundColor Yellow

        $topic = $file.BaseName
        $tempPromptPath = [System.IO.Path]::Combine([System.IO.Path]::GetTempPath(), "gemini_prompt_$(Get-Random).txt")
        $tempResponsePath = [System.IO.Path]::Combine([System.IO.Path]::GetTempPath(), "gemini_response_$(Get-Random).txt")
        
        $finalPrompt = @"
$($styleGuide)

---
**Primary Topic:** `$($topic)`
---

Please generate the content for the topic above, following all the rules.
"@
        
        try {
            Set-Content -Path $tempPromptPath -Value $finalPrompt -Encoding UTF8 -Force
            
            Write-Host "🤖 Gemini에게 '`"$($topic)`"'에 대한 내용 생성을 요청합니다... (cmd.exe 래퍼 사용)"

            # [최종 로직] cmd.exe를 통해 입출력 리디렉션을 모두 처리하여 버전 및 인코딩 문제를 원천 차단
            # 경로에 공백이 있을 수 있으므로 큰따옴표로 감싸줍니다.
            $command = "gemini < `"$tempPromptPath`" > `"$tempResponsePath`""
            cmd.exe /c $command

            # 응답 파일을 UTF8로 안전하게 읽어옴
            if (Test-Path $tempResponsePath) {
                $geminiResponse = Get-Content -Path $tempResponsePath -Raw -Encoding UTF8
            }
            else {
                $geminiResponse = ""
            }

            if ([string]::IsNullOrWhiteSpace($geminiResponse)) {
                Write-Warning "⚠️ Gemini가 빈 응답을 반환했습니다. 파일을 건너뜁니다."
                continue
            }

            Set-Content -Path $file.FullName -Value $geminiResponse -Encoding UTF8 -Force
            Write-Host "✅ 성공: '$($file.Name)' 파일에 생성된 콘텐츠를 저장했습니다." -ForegroundColor Green
        }
        catch {
            Write-Error "❌ 실패: '$($file.Name)' 처리 중 오류 발생."
            Write-Error $_.Exception.Message
        }
        finally {
            # 사용한 임시 파일들을 모두 삭제
            if (Test-Path -Path $tempPromptPath) {
                Remove-Item -Path $tempPromptPath -Force
            }
            if (Test-Path -Path $tempResponsePath) {
                Remove-Item -Path $tempResponsePath -Force
            }
        }
    }
    else {
        Write-Host "☑️ 건너뛰기: '$($file.Name)' 파일은 이미 내용이 있습니다. (크기: $($file.Length) bytes)" -ForegroundColor Gray
    }
}

Write-Host "------------------------------------------------------------"
Write-Host "--- 모든 작업 완료 ---" -ForegroundColor Cyan